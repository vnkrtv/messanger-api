# Домашнее задание к 4 лекции

В рамках этого ДЗ нужно сделать интеграцию сервиса с БД, то есть сохранять историю и состав чатов в БД.

### Условие
1. Добавьте в спеку и реализуйте http-endpoint /ping\_db, который будет являться маркером успешной работы БД. Если БД доступна приложению, endpoint должен возвращать ответ с кодом 200. Если БД не доступна приложению, endpoint должен возвращать ответ с кодом 503 с понятным сообщением об ошибке.
2. Теперь состав чатов и историю сообщений необходимо сохранять в БД. Если приложение сообщило об успешном выполнении запроса, то при перезагрузке приложения или временном отключении БД соответствующие данные не должны никуда пропасть.
3. (\*) Наш мессенджер стал популярным настолько, что им заинтересовались не только джентльмены. Если запрос приходит только с user\_id, доверять ему не следует. Добавьте в мессенджер возможность зарегистрироваться по паре логин + пароль. Вместо того, чтобы завставлять клиента передавать во всех запросах логин + пароль, можно при логине выписать пользователю временный session\_id. ~~Спека будет дополнена описанием необходимых endpoint'ов.~~
4. (\*) Доступ к основной функциональности мессенджера должен быть только у аутентифицированных пользователей. Но для тестов имеет смысл предусмотреть возможность упрощенной аутентификации или полного ее отключения.
5. Мы заметили, что какой-то пользователь начал отправлять десятки сообщений в секунду. Слишком быстро печатает для человека. Что бы нам такого придумать, чтобы быстро предотвратить нецелевое использование нашего мессенджера? Что можно сделать, чтобы вообще не допустить возникновения такой ситуации? Подсказка: почитайте описания http кода 429
6. (\*) Те же вопросы, но для API аутентификации.

### Чек-лист
1. Реализован endpoint /ping\_db
2. Приложение сохраняет состав чатов и историю сообщений в БД. После перезапуска приложения данные не должны пропадать.
3. Если произошло временное отключение БД, после восстановления БД приложение должно восстановить свою работоспособность. По логам приложения можно понять в какие периоды БД была не доступна.
4. Если БД не доступна, приложение должно оставаться функциональным.
5. Создание всех таблиц должно производиться с помощью правильных инструментов миграции. Обязательно использовать Liquibase для миграций, потому что мы хотим проверять можно ли откатить все миграции.
6. (\*) В мессенджере можно зарегистрироваться, залогиниться и разлогиниться. Доступ к основной функциональности мессенджера есть только у залогиненных пользователей.
7. (\*) Клиенты от имени пользователя могут получать сообщения только из тех чатов, где состоит этот пользователь.

### На что обратить внимание
1. При работе с БД используйте пулы соединений, чтобы модерировать нагрузку на БД.
2. Посмотрите как устроен PreparedStatement. Имеет ли смысл использовать его в вашей реализации мессенджера? В каких местах?
3. Подумайте в каких методах мессенджера мог бы использоваться batch insert?
4. Существует несколько практик миграций. Например, миграции может осуществлять отдельный изолированный сервис или же само приложение на старте. Подумайте какие преимущества и недостатки у существующих подходов.
5. Пользователи мессенджера могут оказаться совсем не джентльменами. Подумайте возможны ли SQL-инъекции в ваше приложение. Как от них защититься?
6. Ошибки исполнения запросов к БД не должны вываливаться на пользователя в необработанном виде.
7. Не стоит писать в лог или задействовать в сообщении об ошибках чувствительные данные (пароли к БД, пароли к аккаунтам пользователей, session\_id).

### Как будет производиться тестирование
* Рядом с контейнером мессенджера будет подниматься чистый контейнер с postgresql 12. **connection_string**: `postgresql://${POSTGRES_HOSTS}/${POSTGRES_DB}`, `user=${POSTGRES_USER}`, `password=${POSTGRES_PWD}`, где `${X}` -- это значение переменной окружения `X`
* Контейнер с приложением будет считаться поднятым только после того, как endpoint /ping\_db начнет отвечать с кодом 200.
* В тестах могут быть затронуты произвольные описанные в спеке endpoint'ы.
* Будет проверяться наличие миграций и корректная их накатка\откатка
* (*) По умолчанию запросы к endpoint'ам, закрытым авторизацией, должны **возвращать код 401** для неаутентифицированных пользователей. Отключение такого поведения должно производиться с помощью переменной окружения `AUTH_DISABLED=true`

### Как запустить тесты локально
* Собираем образ с приложением (нужно пересобирать при правках в приложении)
  ```shell
  docker build --network=host -f ./docker/app.dockerfile -t app-messenger .
  ```
* Собираем образ с тестами (нужно собрать 1 раз, при правках в приложении пересобирать не надо)
  ```shell
  docker build --network=host -f ./docker/tests.local.dockerfile -t tests .
  ```
* Запускаем контейнер с тестами (Mac\Linux)
  ```shell
  docker run --network=host --privileged -e IMAGE_NAME=app-messenger -e TESTCONTAINERS_RYUK_DISABLED=true -v /var/run/docker.sock:/var/run/docker.sock --name tests tests 
  ```
* Запускаем контейнер с тестами (Windows)
  ```shell
  docker run --network=host --privileged -e IMAGE_NAME=app-messenger -e TESTCONTAINERS_RYUK_DISABLED=true -v "//var/run/docker.sock:/var/run/docker.sock" --name tests tests 
  ```
* Скачать результаты в текущую директорию
  ```shell
  docker cp tests:opt/messenger/tests/build/reports/tests .
  ```
* Открыть `tests/test/index.html` для получения результатов тестов

------

* Альтернативно вы можете запустить тесты с помощью команд
  (Mac\Linux)
  ```shell
  IMAGE_NAME=app-messenger ./gradlew test -i
  ```

  (Windows)
  ```shell
  IMAGE_NAME=app-messenger ./gradlew.bat test -i
  ```


  ------

#### Возможные проблемы под Windows

**Hints**
* Используйте [WSL2](https://habr.com/en/post/412633/) с Ubuntu 18.04 или новее.
* docker можно запускать под WSL2.

**При запуске контейнра возникает ошибка**
```shell
standard_init_linux.go:228: exec user process caused: no such file or directory
```

Для иправления в файле `docker/main/run.sh` заменить шебанг на 
```shell
#!/usr/bin/bash
```

------

**При запуске CI возникает ошибка**
```shell
com.github.dockerjava.api.exception.BadRequestException: Status 400: {"message":"OCI runtime create failed: container_linux.go:380: starting container process caused: exec: \"/opt/messenger/run.sh\": permission denied: unknown"}
```

Скорее всего это связано с неустановленным битом исполняемости

Можно это исправить, установив бит в git командой
```shell
git update-index --chmod=+x docker/main/run.sh
```

Можно добавить команду установки бита исполняемости в докерфайл `docker/app.dockerfile` 

```shell
# .......

RUN     chmod +x /opt/messenger/run.sh

CMD ["/opt/messenger/run.sh"]

```
